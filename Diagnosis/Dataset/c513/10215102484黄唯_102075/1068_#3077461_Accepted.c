/*
Created by Shizumu on 2022-03-14
	这个题的递推关系需要思考，以连续2个1为例子。
	n = 0 m = 3 --> 0
	不存在嘛 
	n = 1 m = 3 --> 0
	也是tan90不存在 
	n = 2 m = 3 --> 0
	同上
	n = 3 m = 3 --> 1
	111
	n = 4 m = 3 --> 3
	0 111	1 111	111 0
	发现什么没有？至少有两种情况来自上一个，说明map[4][3] = 2 * map[3][3] + ...
	但是，后面还有一托式子，那又是什么呢？再看下面一个 
	n = 5 m = 3 --> 8
	0 0111	0 1111	0 1110	1 0111	1 1111	1 1110
	111 0 0		111 0 1	
	我们知道map[5][3] = 2 * map[4][3] + ... 
	好像还需要加点当111开头的情况.01的话，似乎和map[1][1]有关。现在变成了
		map[5][3] = 2 * map[4][3] + map[1][1] + ...
	同时，还有00，再加一个情况，就是：
		map[5][3] = 2 * map[4][3] + map[1][1] + 1 
	注意到111与map[1][1]中间必须要间隔一个0
	那是不是就是说这个就是正确的呢？我们可以写一下n = 6, 7的情况（这里不再赘述）， 
就会发现 111 0 后面也有可能出现三个连续出现的1（前面比较短，不容易发现罢了），于
是我们还应当在上面的得到的式子基础上减去这个情况，这就是下面递推式的由来。 
*/ 
#include <stdio.h>
#include <math.h>

typedef long long int lli;
lli map[32][32];

void solve(void){
	for(int i = 0; i < 32; i ++){
		map[i][i] = 1;
	}
	for(int i = 1; i < 32; i ++){
		for(int j = 1; j < 32; j ++){
			if(i > j){
				map[i][j] = 2 * map[i - 1][j] + map[i - j - 1][1] - map[i - j - 1][j] + 1;
			}		
		}
	}
}


int main(void)
{
	lli n, m;
	scanf("%lld %lld", &n, &m);
	solve();
	while(n != -1 && m != -1){
		lli res = map[n][m];
		printf("%lld\n", res);
		scanf("%lld %lld", &n, &m);
	}
	
	return 0;
}
